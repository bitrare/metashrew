--- a/crates/metashrew-support/src/lru_cache.rs
+++ b/crates/metashrew-support/src/lru_cache.rs
@@ -754,15 +754,8 @@ impl From<CacheValue> for Arc<Vec<u8>> {
 impl HeapSize for CacheValue {
     fn heap_size(&self) -> usize {
-        // More accurate memory calculation:
-        // - Arc overhead (reference counting, etc.)
-        // - Vec overhead (capacity, length, pointer)
-        // - Actual data size
-        // - Additional overhead for heap allocation alignment
-        let arc_overhead = std::mem::size_of::<Arc<Vec<u8>>>() * 2; // Conservative estimate
-        let vec_overhead = std::mem::size_of::<Vec<u8>>() + std::mem::size_of::<usize>(); // capacity overhead
-        let data_size = self.0.len();
-        let alignment_overhead = (data_size + 7) & !7; // 8-byte alignment padding
-
-        arc_overhead + vec_overhead + alignment_overhead
+        // Simple and accurate memory calculation:
+        // Just the data size plus minimal overhead for Arc and Vec structures
+        std::mem::size_of::<Arc<Vec<u8>>>() + std::mem::size_of::<Vec<u8>>() + self.0.len()
     }
 }
 
@@ -786,15 +779,8 @@ impl From<CacheKey> for Arc<Vec<u8>> {
 impl HeapSize for CacheKey {
     fn heap_size(&self) -> usize {
-        // More accurate memory calculation for keys
-        let arc_overhead = std::mem::size_of::<Arc<Vec<u8>>>() * 2; // Conservative estimate
-        let vec_overhead = std::mem::size_of::<Vec<u8>>() + std::mem::size_of::<usize>(); // capacity overhead
-        let data_size = self.0.len();
-        let alignment_overhead = (data_size + 7) & !7; // 8-byte alignment padding
-
-        arc_overhead + vec_overhead + alignment_overhead
+        // Simple and accurate memory calculation for keys
+        std::mem::size_of::<Arc<Vec<u8>>>() + std::mem::size_of::<Vec<u8>>() + self.0.len()
     }
 }
 